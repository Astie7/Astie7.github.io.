<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rules · Pantheverse</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap">
    <link rel="icon" type="image/webp" href="../Pantheverse.webp">
    <link rel="stylesheet" href="../critical.css">
    <link rel="preload" href="../style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="../style.css"></noscript>
    <script src="../supabase-config.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="page page-rules">
    <header class="shell topbar">
        <div class="brand">
            <span class="dot"></span>
            <span data-setting-key="brand_name">Pantheverse</span>
        </div>
        <nav class="nav">
            <a href="../">Home</a>
            <a class="active" href="./">Rules</a>
            <a href="../about/">About</a>
            <button id="top-auth-btn" class="btn btn-ghost auth-top-btn" type="button">Login / Register</button>
            <button id="top-signout-btn" class="btn btn-ghost auth-top-btn" type="button">Sign out</button>
            <a class="btn btn-primary" data-setting-key="discord_invite_url" data-setting-attr="href" href="https://discord.gg/9qpju32M2S" target="_blank" rel="noopener">Join Discord</a>
        </nav>
    </header>

    <main class="shell forum-home forum-rules-page">
        <section class="forum-banner forum-panel">
            <div>
                <p class="eyebrow">Policy Board</p>
                <h1>Rules & Moderation Forum</h1>
                <p>This board keeps all community rules synced and publicly readable. Approved editors can update the list live.</p>
            </div>
            <div class="forum-banner-actions">
                <a class="btn btn-primary" href="../">Back to forum</a>
                <a class="btn btn-ghost" data-setting-key="discord_invite_url" data-setting-attr="href" href="https://discord.gg/9qpju32M2S" target="_blank" rel="noopener">Open Discord</a>
            </div>
        </section>

        <section class="forum-grid forum-rules-grid">
            <aside class="forum-panel forum-sidebar">
                <h3>Policy Boards</h3>
                <ul class="forum-list">
                    <li><a class="active" href="./">Rules feed</a></li>
                    <li><a href="../">General forum</a></li>
                    <li><a href="../about/">Meta board</a></li>
                </ul>
                <div class="forum-small-stats">
                    <span>Board: Public</span>
                    <span>Sync: Realtime</span>
                    <span>Role: Editor-gated</span>
                </div>
            </aside>

            <section class="forum-panel forum-feed forum-rules-feed">
                <section class="rules-hero-card">
                    <div class="section-head rules-head">
                        <p class="eyebrow">Rules</p>
                        <h2>Divine Laws of Pantheverse <span aria-hidden="true">∞</span></h2>
                        <p class="rules-lead">These keep the energy high and the space safe. Know them before you dive in.</p>
                    </div>

                    <aside class="rules-admin-card">
                        <div class="rules-auth">
                            <div class="auth-state-wrap">
                                <div id="auth-state" class="auth-state">Public mode</div>
                                <p id="auth-user" class="auth-user">Sign in to edit rules.</p>
                                <p class="auth-hint">Everyone can view. Approved editors can change rules.</p>
                            </div>
                        </div>

                        <div id="rules-controls" class="rules-controls">
                            <button id="enter-edit-btn" class="edit-btn" type="button">Enter edit mode</button>
                            <button id="exit-edit-btn" class="btn btn-ghost" type="button">Exit edit mode</button>
                        </div>
                    </aside>
                </section>

                <div id="edit-panel" class="rules-edit-panel">
                    <div class="edit-row">
                        <input id="new-rule" class="edit-input" type="text" placeholder="Add a new rule..." />
                        <button id="add-rule-btn" class="edit-btn" type="button">+ Add rule</button>
                    </div>
                    <div class="bulk-row">
                        <button id="select-all-btn" class="btn btn-ghost" type="button">Select all</button>
                        <button id="clear-selection-btn" class="btn btn-ghost" type="button">Clear</button>
                        <button id="delete-selected-btn" class="btn btn-ghost danger" type="button">Delete selected</button>
                        <span id="selected-count" class="bulk-count">0 selected</span>
                    </div>
                    <p class="edit-note">Editor mode is on. Changes are saved to Supabase and shown live to everyone.</p>
                </div>

                <ul id="rules-list" class="rules-list"></ul>

                <div class="forum-callout">
                    <strong>Future decrees</strong>
                    <p>More rules can be added as Pantheverse grows. Keep updates concise and post one policy per line.</p>
                </div>
            </section>

            <aside class="forum-panel forum-sidecards">
                <h3>Moderation Queue</h3>
                <ul class="forum-mini-list">
                    <li>Pending: tag cleanup policy</li>
                    <li>Pending: appeal format update</li>
                    <li>Resolved: alt-account wording</li>
                </ul>
                <div class="forum-callout">
                    <strong>Editing note</strong>
                    <p>When edit mode is enabled, changes sync live for everyone viewing this board.</p>
                </div>
            </aside>
        </section>
    </main>

    <div id="auth-modal" class="auth-modal" aria-hidden="true">
        <div class="auth-card">
            <div class="auth-head">
                <h3>Pantheverse Login</h3>
                <p>Sign in, or create an account with email verification.</p>
            </div>
            <div class="auth-body">
                <div class="auth-mode-tabs">
                    <button id="auth-mode-signin" class="auth-mode-btn active" type="button">Login</button>
                    <button id="auth-mode-register" class="auth-mode-btn" type="button">Create account</button>
                </div>
                <div class="auth-field-group">
                    <label for="auth-email">Email address</label>
                    <input id="auth-email" class="edit-input" type="email" placeholder="you@example.com" autocomplete="email">
                </div>
                <div id="auth-password-wrap" class="auth-field-group">
                    <label for="auth-password">Password</label>
                    <input id="auth-password" class="edit-input" type="password" placeholder="Password" autocomplete="current-password">
                </div>
                <div id="auth-confirm-wrap" class="auth-field-group" style="display:none;">
                    <label for="auth-confirm-password">Confirm password</label>
                    <input id="auth-confirm-password" class="edit-input" type="password" placeholder="Confirm password" autocomplete="new-password">
                </div>
                <div id="auth-code-wrap" class="auth-field-group auth-code-group" style="display:none;">
                    <label for="auth-code">Verification code</label>
                    <div class="auth-code-row">
                        <input id="auth-code" class="edit-input" type="text" placeholder="Enter code from email" autocomplete="one-time-code">
                        <button id="auth-send-code-btn" class="btn btn-ghost auth-inline-btn" type="button">Send code</button>
                        <button id="auth-resend-code-btn" class="btn btn-ghost auth-inline-btn auth-inline-secondary" type="button">Resend</button>
                    </div>
                </div>
                <div class="auth-card-actions">
                    <button id="auth-login-btn" class="edit-btn" type="button">Login now</button>
                    <button id="auth-register-btn" class="edit-btn" type="button">Create account</button>
                    <button id="auth-cancel-btn" class="btn btn-ghost" type="button">Cancel</button>
                </div>
            </div>
            <p id="auth-message" class="auth-message"></p>
        </div>
    </div>

    <div id="confirm-modal" class="confirm-modal" aria-hidden="true" hidden>
        <div class="confirm-card">
            <h3 id="confirm-title">Confirm action</h3>
            <p id="confirm-text">Are you sure?</p>
            <div class="confirm-actions">
                <button id="confirm-ok" class="edit-btn" type="button">Confirm</button>
                <button id="confirm-cancel" class="btn btn-ghost" type="button">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rules-toast" class="rules-toast" aria-live="polite" aria-atomic="true"></div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            (function() {
            const config = window.PV_SUPABASE || {};
            const hasSupabaseConfig = !!(config.url && config.anonKey && window.supabase && window.supabase.createClient);
            const enterEditBtn = document.getElementById('enter-edit-btn');
            const exitEditBtn = document.getElementById('exit-edit-btn');
            const controls = document.getElementById('rules-controls');
            const panel = document.getElementById('edit-panel');
            const listEl = document.getElementById('rules-list');
            const addBtn = document.getElementById('add-rule-btn');
            const newInput = document.getElementById('new-rule');
            const selectAllBtn = document.getElementById('select-all-btn');
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            const deleteSelectedBtn = document.getElementById('delete-selected-btn');
            const selectedCountEl = document.getElementById('selected-count');
            const authStateEl = document.getElementById('auth-state');
            const authUserEl = document.getElementById('auth-user');
            const topAuthBtn = document.getElementById('top-auth-btn');
            const topSignoutBtn = document.getElementById('top-signout-btn');
            const brandEl = document.querySelector('.topbar .brand');
            const brandNameEl = brandEl ? brandEl.querySelector('span[data-setting-key="brand_name"], span:last-child') : null;

            const accountMarkup = [
                '<div id="brand-account-menu" class="brand-account-menu" hidden>',
                '  <div id="brand-account-label" class="brand-account-label"></div>',
                '  <button id="brand-account-settings" class="brand-account-item" type="button">Settings</button>',
                '  <button id="brand-account-signout" class="brand-account-item danger" type="button">Sign out</button>',
                '</div>',
                '<div id="account-settings-modal" class="account-settings-modal" aria-hidden="true">',
                '  <div class="account-settings-card">',
                '    <h3>Account settings</h3>',
                '    <label for="account-display-name">Username</label>',
                '    <input id="account-display-name" class="edit-input" type="text" placeholder="Choose a username" autocomplete="nickname">',
                '    <p id="account-settings-msg" class="account-settings-msg"></p>',
                '    <div class="account-settings-actions">',
                '      <button id="account-settings-save" class="edit-btn" type="button">Save</button>',
                '      <button id="account-settings-cancel" class="btn btn-ghost" type="button">Close</button>',
                '    </div>',
                '  </div>',
                '</div>'
            ].join('');
            document.body.insertAdjacentHTML('beforeend', accountMarkup);

            const authModal = document.getElementById('auth-modal');
            const authModeSigninBtn = document.getElementById('auth-mode-signin');
            const authModeRegisterBtn = document.getElementById('auth-mode-register');
            const authEmail = document.getElementById('auth-email');
            const authPasswordWrap = document.getElementById('auth-password-wrap');
            const authPassword = document.getElementById('auth-password');
            const authConfirmWrap = document.getElementById('auth-confirm-wrap');
            const authConfirmPassword = document.getElementById('auth-confirm-password');
            const authCodeWrap = document.getElementById('auth-code-wrap');
            const authCode = document.getElementById('auth-code');
            const authLoginBtn = document.getElementById('auth-login-btn');
            const authRegisterBtn = document.getElementById('auth-register-btn');
            const authSendCodeBtn = document.getElementById('auth-send-code-btn');
            const authResendCodeBtn = document.getElementById('auth-resend-code-btn');
            const authCancelBtn = document.getElementById('auth-cancel-btn');
            const authMessage = document.getElementById('auth-message');
            const confirmModal = document.getElementById('confirm-modal');
            const confirmTitle = document.getElementById('confirm-title');
            const confirmText = document.getElementById('confirm-text');
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            const toastEl = document.getElementById('rules-toast');
            const brandAccountMenu = document.getElementById('brand-account-menu');
            const brandAccountLabel = document.getElementById('brand-account-label');
            const brandAccountSettingsBtn = document.getElementById('brand-account-settings');
            const brandAccountSignoutBtn = document.getElementById('brand-account-signout');
            const accountSettingsModal = document.getElementById('account-settings-modal');
            const accountDisplayNameInput = document.getElementById('account-display-name');
            const accountSettingsMsg = document.getElementById('account-settings-msg');
            const accountSettingsSaveBtn = document.getElementById('account-settings-save');
            const accountSettingsCancelBtn = document.getElementById('account-settings-cancel');

            const defaultRules = [
                'NSFW is eternally forbidden and is never allowed in any form.',
                'Racism, hate speech, or discrimination is forbidden across all realms.',
                'Spamming is allowed only if it doesn’t intentionally harm or break the server.',
                'Advertising or promoting unrelated servers is forbidden.',
                'Impersonation of members, bots, or entities is forbidden.',
                'Malicious links, scams, or harmful content are forbidden.',
                'Respect channel order — post content where it belongs.',
                'Evading punishments or bypassing restrictions is forbidden.',
                'Excessive disruption intended to ruin others’ experience is forbidden.',
                'Alternate accounts used for abuse or evasion are forbidden.',
                'Use reason and restraint — loopholes do not grant immunity.'
            ];

            const state = {
                client: null,
                session: null,
                isEditor: false,
                editMode: false,
                rules: [],
                channel: null,
                confirmResolver: null,
                toastTimer: null,
                dragRuleId: null,
                pending: false,
                selectedRuleIds: new Set(),
                authMode: 'signin',
                defaultBrandName: brandNameEl ? (brandNameEl.textContent || '').trim() : 'Pantheverse'
            };

            function setAuthMessage(message, isError) {
                authMessage.textContent = message;
                authMessage.className = isError ? 'auth-message error' : 'auth-message';
            }

            function setAccountSettingsMessage(message, isError) {
                if (!accountSettingsMsg) return;
                accountSettingsMsg.textContent = message || '';
                accountSettingsMsg.className = isError ? 'account-settings-msg error' : 'account-settings-msg';
            }

            function getDisplayName(user) {
                if (!user) return state.defaultBrandName;
                const meta = user.user_metadata || {};
                const fromMeta = meta.username || meta.display_name || meta.full_name || meta.name;
                if (fromMeta && String(fromMeta).trim()) return String(fromMeta).trim();
                const email = user.email || '';
                if (email.includes('@')) return email.split('@')[0];
                return state.defaultBrandName;
            }

            function closeBrandMenu() {
                if (!brandAccountMenu) return;
                brandAccountMenu.hidden = true;
                brandAccountMenu.classList.remove('open');
            }

            function openBrandMenu() {
                if (!brandAccountMenu || !state.session) return;
                brandAccountMenu.hidden = false;
                brandAccountMenu.classList.add('open');
            }

            function toggleBrandMenu() {
                if (!brandAccountMenu || !state.session) return;
                if (brandAccountMenu.hidden) {
                    openBrandMenu();
                    return;
                }
                closeBrandMenu();
            }

            function openAccountSettingsModal() {
                if (!accountSettingsModal || !state.session) return;
                accountSettingsModal.classList.add('open');
                accountSettingsModal.setAttribute('aria-hidden', 'false');
                accountDisplayNameInput.value = getDisplayName(state.session.user);
                setAccountSettingsMessage('', false);
                accountDisplayNameInput.focus();
            }

            function closeAccountSettingsModal() {
                if (!accountSettingsModal) return;
                accountSettingsModal.classList.remove('open');
                accountSettingsModal.setAttribute('aria-hidden', 'true');
                setAccountSettingsMessage('', false);
            }

            function syncBrandAccount() {
                if (!brandEl || !brandNameEl) return;
                if (!state.session) {
                    brandNameEl.textContent = state.defaultBrandName;
                    brandEl.classList.remove('brand-account-enabled');
                    brandEl.removeAttribute('role');
                    brandEl.removeAttribute('tabindex');
                    closeBrandMenu();
                    closeAccountSettingsModal();
                    return;
                }

                const displayName = getDisplayName(state.session.user);
                brandNameEl.textContent = displayName;
                brandEl.classList.add('brand-account-enabled');
                brandEl.setAttribute('role', 'button');
                brandEl.setAttribute('tabindex', '0');
                if (brandAccountLabel) {
                    brandAccountLabel.textContent = displayName;
                }
            }

            function setAuthActionBusy(isBusy) {
                authModeSigninBtn.disabled = isBusy;
                authModeRegisterBtn.disabled = isBusy;
                authEmail.disabled = isBusy;
                authPassword.disabled = isBusy;
                authConfirmPassword.disabled = isBusy;
                authCode.disabled = isBusy;
                authLoginBtn.disabled = isBusy;
                authRegisterBtn.disabled = isBusy;
                authSendCodeBtn.disabled = isBusy;
                authResendCodeBtn.disabled = isBusy;
                authCancelBtn.disabled = isBusy;
            }

            function setAuthState(text) {
                authStateEl.textContent = text;
            }

            function setAuthUser(text) {
                authUserEl.textContent = text;
            }

            function setAuthMode(mode) {
                state.authMode = mode;
                const isSignin = mode === 'signin';
                const isRegister = mode === 'register';

                authModeSigninBtn.classList.toggle('active', isSignin);
                authModeRegisterBtn.classList.toggle('active', isRegister);

                authPasswordWrap.style.display = 'block';
                authConfirmWrap.style.display = isRegister ? 'block' : 'none';
                authCodeWrap.style.display = isRegister ? 'block' : 'none';

                authLoginBtn.style.display = isSignin ? 'inline-flex' : 'none';
                authRegisterBtn.style.display = isRegister ? 'inline-flex' : 'none';
                authSendCodeBtn.style.display = isRegister ? 'inline-flex' : 'none';
                authResendCodeBtn.style.display = isRegister ? 'inline-flex' : 'none';
                setAuthMessage('', false);
            }

            function openAuthModal() {
                authModal.classList.add('open');
                authModal.setAttribute('aria-hidden', 'false');
                setAuthMode('signin');
                setAuthActionBusy(false);
                setAuthMessage('', false);
                authEmail.focus();
            }

            function closeAuthModal() {
                authModal.classList.remove('open');
                authModal.setAttribute('aria-hidden', 'true');
                setAuthActionBusy(false);
                authPassword.value = '';
                authConfirmPassword.value = '';
                authCode.value = '';
                setAuthMessage('', false);
            }

            function openConfirmModal(title, message) {
                confirmTitle.textContent = title;
                confirmText.textContent = message;
                confirmModal.hidden = false;
                confirmModal.classList.add('open');
                confirmModal.setAttribute('aria-hidden', 'false');
            }

            function closeConfirmModal() {
                confirmModal.classList.remove('open');
                confirmModal.setAttribute('aria-hidden', 'true');
                confirmModal.hidden = true;
            }

            function askConfirm(title, message) {
                openConfirmModal(title, message);
                return new Promise((resolve) => {
                    state.confirmResolver = resolve;
                });
            }

            function resolveConfirm(value) {
                const resolver = state.confirmResolver;
                state.confirmResolver = null;
                closeConfirmModal();
                if (typeof resolver === 'function') {
                    resolver(value);
                }
            }

            function showToast(message, kind) {
                if (!toastEl) return;
                if (state.toastTimer) {
                    clearTimeout(state.toastTimer);
                    state.toastTimer = null;
                }
                toastEl.textContent = message;
                toastEl.className = 'rules-toast';
                if (kind === 'error') toastEl.classList.add('is-error');
                toastEl.classList.add('open');
                state.toastTimer = setTimeout(function() {
                    toastEl.classList.remove('open');
                    state.toastTimer = null;
                }, 1900);
            }

            function getSortedRules() {
                return state.rules.slice().sort((a, b) => (a.position || 0) - (b.position || 0));
            }

            function setBusy(flag) {
                state.pending = !!flag;
                addBtn.disabled = state.pending;
                selectAllBtn.disabled = state.pending;
                clearSelectionBtn.disabled = state.pending;
                deleteSelectedBtn.disabled = state.pending || state.selectedRuleIds.size === 0;
            }

            function updateSelectionUi() {
                selectedCountEl.textContent = state.selectedRuleIds.size + ' selected';
                deleteSelectedBtn.disabled = state.pending || state.selectedRuleIds.size === 0;
            }

            function moveRuleBefore(dragRuleId, targetRuleId) {
                const sorted = getSortedRules();
                const fromIndex = sorted.findIndex(function(rule) { return rule.id === dragRuleId; });
                const toIndex = sorted.findIndex(function(rule) { return rule.id === targetRuleId; });
                if (fromIndex < 0 || toIndex < 0 || fromIndex === toIndex) return false;

                const moved = sorted.splice(fromIndex, 1)[0];
                sorted.splice(toIndex, 0, moved);
                state.rules = sorted.map(function(rule, index) {
                    return Object.assign({}, rule, { position: index + 1 });
                });
                return true;
            }

            function render() {
                listEl.innerHTML = '';
                const rules = getSortedRules();

                const validIds = new Set(
                    rules.filter(function(rule) {
                        return !!rule.id;
                    }).map(function(rule) {
                        return rule.id;
                    })
                );
                state.selectedRuleIds.forEach(function(id) {
                    if (!validIds.has(id)) state.selectedRuleIds.delete(id);
                });
                updateSelectionUi();

                if (!rules.length) {
                    const li = document.createElement('li');
                    const span = document.createElement('span');
                    span.className = 'rule-text';
                    span.textContent = 'No rules found yet.';
                    li.appendChild(span);
                    listEl.appendChild(li);
                    return;
                }

                rules.forEach((rule) => {
                    const li = document.createElement('li');
                    li.dataset.ruleId = rule.id || '';
                    const span = document.createElement('span');
                    span.className = 'rule-text';
                    span.textContent = rule.text;

                    if (state.isEditor && state.editMode && rule.id) {
                        li.classList.add('is-draggable');
                        li.draggable = !state.pending;

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'rule-select';
                        checkbox.checked = state.selectedRuleIds.has(rule.id);
                        checkbox.disabled = state.pending;
                        checkbox.addEventListener('change', function() {
                            if (checkbox.checked) {
                                state.selectedRuleIds.add(rule.id);
                            } else {
                                state.selectedRuleIds.delete(rule.id);
                            }
                            updateSelectionUi();
                        });
                        li.appendChild(checkbox);

                        const handle = document.createElement('button');
                        handle.type = 'button';
                        handle.className = 'drag-handle';
                        handle.textContent = '::';
                        handle.title = 'Drag to reorder';
                        handle.disabled = state.pending;
                        li.appendChild(handle);

                        li.addEventListener('dragstart', function() {
                            state.dragRuleId = rule.id;
                            li.classList.add('is-dragging');
                        });
                        li.addEventListener('dragend', function() {
                            state.dragRuleId = null;
                            li.classList.remove('is-dragging');
                            li.classList.remove('drag-over');
                        });
                        li.addEventListener('dragover', function(event) {
                            if (!state.dragRuleId || state.dragRuleId === rule.id) return;
                            event.preventDefault();
                            li.classList.add('drag-over');
                        });
                        li.addEventListener('dragleave', function() {
                            li.classList.remove('drag-over');
                        });
                        li.addEventListener('drop', function(event) {
                            event.preventDefault();
                            li.classList.remove('drag-over');
                            if (moveRuleBefore(state.dragRuleId, rule.id)) {
                                render();
                                saveRuleOrder();
                            }
                        });

                        li.appendChild(span);

                        const actions = document.createElement('div');
                        actions.className = 'rule-actions';

                        const del = document.createElement('button');
                        del.className = 'delete-rule-btn';
                        del.textContent = 'Delete';
                        del.type = 'button';
                        del.disabled = state.pending;
                        del.addEventListener('click', () => deleteRule(rule.id));

                        actions.appendChild(del);
                        li.appendChild(actions);
                        actions.style.display = 'flex';
                    } else {
                        li.appendChild(span);
                    }
                    listEl.appendChild(li);
                });
            }

            function applyUiState() {
                if (hasSupabaseConfig) {
                    topSignoutBtn.style.display = 'none';
                    topAuthBtn.style.display = state.session ? 'none' : 'inline-flex';
                } else {
                    topSignoutBtn.style.display = 'none';
                    topAuthBtn.style.display = 'none';
                }
                syncBrandAccount();
                controls.style.display = state.isEditor ? 'flex' : 'none';
                enterEditBtn.style.display = state.editMode ? 'none' : 'inline-flex';
                exitEditBtn.style.display = state.editMode ? 'inline-flex' : 'none';
                panel.style.display = state.isEditor && state.editMode ? 'flex' : 'none';
                document.body.classList.toggle('is-edit-mode', !!state.editMode);
                if (!state.editMode) {
                    state.selectedRuleIds.clear();
                }
                setBusy(state.pending);
                render();
            }

            async function checkEditorAccess() {
                if (!state.client || !state.session) return false;
                const userId = state.session.user.id;
                const { data, error } = await state.client
                    .from('editors')
                    .select('user_id')
                    .eq('user_id', userId)
                    .maybeSingle();

                if (error && error.code !== 'PGRST116') {
                    console.error(error);
                    return false;
                }
                return !!data;
            }

            async function loadRules() {
                if (!state.client) {
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                    render();
                    return;
                }
                const { data, error } = await state.client
                    .from('rules')
                    .select('id, position, text')
                    .order('position', { ascending: true });

                if (error) {
                    console.error(error);
                    setAuthState('Rules failed to load.');
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                } else {
                    state.rules = data || [];
                }
                render();
            }

            async function persistRuleOrderViaUpdates() {
                const sorted = getSortedRules().filter(function(rule) {
                    return !!rule.id && !String(rule.id).startsWith('tmp:');
                });
                const offset = sorted.length + 1000;

                for (let i = 0; i < sorted.length; i++) {
                    const row = sorted[i];
                    const { error } = await state.client
                        .from('rules')
                        .update({ position: offset + i + 1 })
                        .eq('id', row.id);
                    if (error) return { error: error };
                }

                for (let i = 0; i < sorted.length; i++) {
                    const row = sorted[i];
                    const { error } = await state.client
                        .from('rules')
                        .update({ position: i + 1 })
                        .eq('id', row.id);
                    if (error) return { error: error };
                }

                return { error: null };
            }

            async function persistRuleOrder() {
                if (!state.client) return { error: null };
                const ids = getSortedRules()
                    .filter(function(rule) { return !!rule.id && !String(rule.id).startsWith('tmp:'); })
                    .map(function(rule) { return rule.id; });
                if (!ids.length) return { error: null };
                const rpcResult = await state.client.rpc('reorder_rules', { rule_ids: ids });
                if (!rpcResult.error) return rpcResult;
                return persistRuleOrderViaUpdates();
            }

            async function saveRuleOrder() {
                if (!state.client || !state.isEditor || !state.editMode) return;
                if (state.pending) return;
                setBusy(true);
                const { error } = await persistRuleOrder();
                if (error) {
                    showToast('Order save failed.', 'error');
                    console.error(error);
                    await loadRules();
                    setBusy(false);
                    return;
                }
                await loadRules();
                setBusy(false);
                showToast('Order saved.');
            }

            async function addRule() {
                if (!state.isEditor || state.pending) return;
                const text = newInput.value.trim();
                if (!text) return;

                setBusy(true);

                const maxPos = state.rules.reduce((m, r) => Math.max(m, r.position || 0), 0);
                const { error } = await state.client
                    .from('rules')
                    .insert({ text: text, position: maxPos + 1 })
                    .select('id')
                    .single();
                if (error) {
                    setAuthState('Add failed.');
                    showToast('Add failed.', 'error');
                    console.error(error);
                    setBusy(false);
                    return;
                }
                newInput.value = '';
                await loadRules();
                setBusy(false);
                showToast('Rule added.');
            }

            async function deleteRule(ruleId) {
                if (!state.isEditor || state.pending) return;
                const allowed = await askConfirm('Delete rule', 'Delete this rule?');
                if (!allowed) return;
                setBusy(true);

                const { error } = await state.client.from('rules').delete().eq('id', ruleId);
                if (error) {
                    setAuthState('Delete failed.');
                    showToast('Delete failed.', 'error');
                    console.error(error);
                    setBusy(false);
                    return;
                }
                state.selectedRuleIds.delete(ruleId);
                const orderResult = await persistRuleOrder();
                if (orderResult.error) {
                    await loadRules();
                    showToast('Rule deleted, reorder sync failed.', 'error');
                    console.error(orderResult.error);
                    setBusy(false);
                    return;
                }
                await loadRules();
                setBusy(false);
                showToast('Rule deleted.');
            }

            async function deleteSelectedRules() {
                if (!state.isEditor || state.pending) return;
                const ids = Array.from(state.selectedRuleIds);
                if (!ids.length) return;
                const allowed = await askConfirm('Delete selected', 'Delete ' + ids.length + ' selected rules?');
                if (!allowed) return;
                setBusy(true);

                const { error } = await state.client.from('rules').delete().in('id', ids);
                if (error) {
                    setAuthState('Delete failed.');
                    showToast('Delete failed.', 'error');
                    console.error(error);
                    setBusy(false);
                    return;
                }
                state.selectedRuleIds.clear();
                const orderResult = await persistRuleOrder();
                if (orderResult.error) {
                    await loadRules();
                    showToast('Rules deleted, reorder sync failed.', 'error');
                    console.error(orderResult.error);
                    setBusy(false);
                    return;
                }
                await loadRules();
                setBusy(false);
                showToast(ids.length + ' rules deleted.');
            }

            function bindEvents() {
                enterEditBtn.addEventListener('click', () => {
                    if (!state.isEditor) {
                        return;
                    }
                    askConfirm('Edit mode', 'Enter edit mode?').then((allowed) => {
                        if (!allowed) return;
                        state.editMode = true;
                        applyUiState();
                    });
                });

                exitEditBtn.addEventListener('click', () => {
                    askConfirm('Edit mode', 'Exit edit mode?').then((allowed) => {
                        if (!allowed) return;
                        state.editMode = false;
                        applyUiState();
                    });
                });

                addBtn.addEventListener('click', addRule);
                newInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') addRule();
                });
                selectAllBtn.addEventListener('click', function() {
                    if (state.pending) return;
                    getSortedRules().forEach(function(rule) {
                        if (rule.id) state.selectedRuleIds.add(rule.id);
                    });
                    render();
                });
                clearSelectionBtn.addEventListener('click', function() {
                    if (state.pending) return;
                    state.selectedRuleIds.clear();
                    render();
                });
                deleteSelectedBtn.addEventListener('click', deleteSelectedRules);

                topAuthBtn.addEventListener('click', openAuthModal);
                authCancelBtn.addEventListener('click', closeAuthModal);
                authModal.addEventListener('click', (e) => {
                    if (e.target === authModal) closeAuthModal();
                });
                if (brandEl) {
                    brandEl.addEventListener('click', function() {
                        if (!state.session) return;
                        toggleBrandMenu();
                    });
                    brandEl.addEventListener('keydown', function(event) {
                        if (!state.session) return;
                        if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            toggleBrandMenu();
                        }
                    });
                }
                if (brandAccountSettingsBtn) {
                    brandAccountSettingsBtn.addEventListener('click', function() {
                        closeBrandMenu();
                        openAccountSettingsModal();
                    });
                }
                if (brandAccountSignoutBtn) {
                    brandAccountSignoutBtn.addEventListener('click', async function() {
                        closeBrandMenu();
                        if (!state.client) return;
                        await state.client.auth.signOut();
                    });
                }
                if (accountSettingsSaveBtn) {
                    accountSettingsSaveBtn.addEventListener('click', async function() {
                        if (!state.client || !state.session) return;
                        const username = (accountDisplayNameInput.value || '').trim();
                        if (!username) {
                            setAccountSettingsMessage('Username is required.', true);
                            return;
                        }
                        accountSettingsSaveBtn.disabled = true;
                        const { error } = await state.client.auth.updateUser({
                            data: { username: username }
                        });
                        accountSettingsSaveBtn.disabled = false;
                        if (error) {
                            setAccountSettingsMessage(error.message || 'Failed to save username.', true);
                            return;
                        }
                        setAccountSettingsMessage('Saved.', false);
                        const sessionResult = await state.client.auth.getSession();
                        state.session = sessionResult && sessionResult.data ? sessionResult.data.session : state.session;
                        syncBrandAccount();
                    });
                }
                if (accountSettingsCancelBtn) {
                    accountSettingsCancelBtn.addEventListener('click', closeAccountSettingsModal);
                }
                if (accountSettingsModal) {
                    accountSettingsModal.addEventListener('click', function(event) {
                        if (event.target === accountSettingsModal) closeAccountSettingsModal();
                    });
                }
                authModeSigninBtn.addEventListener('click', function() {
                    setAuthMode('signin');
                    authPassword.focus();
                });
                authModeRegisterBtn.addEventListener('click', function() {
                    setAuthMode('register');
                    authPassword.focus();
                });
                confirmModal.addEventListener('click', (e) => {
                    if (e.target === confirmModal) resolveConfirm(false);
                });
                confirmOk.addEventListener('click', () => resolveConfirm(true));
                confirmCancel.addEventListener('click', () => resolveConfirm(false));

                authLoginBtn.addEventListener('click', async () => {
                    if (!state.client) return;
                    const email = authEmail.value.trim();
                    const password = authPassword.value;
                    if (!email || !password) {
                        setAuthMessage('Email and password are required.', true);
                        return;
                    }
                    setAuthActionBusy(true);
                    const { error } = await state.client.auth.signInWithPassword({ email: email, password: password });
                    if (error) {
                        setAuthMessage(error.message || 'Sign in failed.', true);
                        setAuthActionBusy(false);
                        return;
                    }
                    setAuthActionBusy(false);
                    closeAuthModal();
                });

                function validateRegisterFields(requireCode) {
                    if (!state.client) return;
                    const email = authEmail.value.trim();
                    const password = authPassword.value;
                    const confirmPassword = authConfirmPassword.value;
                    const code = authCode.value.trim().replace(/\s+/g, '');
                    if (!email || !password) {
                        setAuthMessage('Email and password are required.', true);
                        return null;
                    }
                    if (password.length < 6) {
                        setAuthMessage('Use at least 6 characters for password.', true);
                        return null;
                    }
                    if (password !== confirmPassword) {
                        setAuthMessage('Passwords do not match.', true);
                        return null;
                    }
                    if (requireCode && !code) {
                        setAuthMessage('Verification code is required.', true);
                        return null;
                    }
                    return { email: email, password: password, code: code };
                }

                authRegisterBtn.addEventListener('click', async () => {
                    if (!state.client) return;
                    const form = validateRegisterFields(true);
                    if (!form) return;
                    setAuthActionBusy(true);
                    const { error } = await state.client.auth.verifyOtp({
                        email: form.email,
                        token: form.code,
                        type: 'email'
                    });
                    if (error) {
                        setAuthMessage(error.message || 'Code verification failed.', true);
                        setAuthActionBusy(false);
                        return;
                    }
                    const updateResult = await state.client.auth.updateUser({ password: form.password });
                    if (updateResult.error) {
                        setAuthMessage(updateResult.error.message || 'Password setup failed.', true);
                        setAuthActionBusy(false);
                        return;
                    }
                    setAuthActionBusy(false);
                    closeAuthModal();
                });

                async function sendCodeMessage(isResend) {
                    if (!state.client) return;
                    const form = validateRegisterFields(false);
                    if (!form) return;
                    setAuthActionBusy(true);
                    const redirectUrl = config.authRedirectTo || window.location.href.split('#')[0].split('?')[0];
                    const { error } = await state.client.auth.signInWithOtp({
                        email: form.email,
                        options: {
                            shouldCreateUser: true,
                            emailRedirectTo: redirectUrl
                        }
                    });
                    if (error) {
                        setAuthMessage(error.message || 'Failed to send code.', true);
                        setAuthActionBusy(false);
                        return;
                    }
                    setAuthActionBusy(false);
                    setAuthMessage(isResend ? 'Code resent. Check your inbox.' : 'Code sent. Check your inbox.', false);
                }

                authSendCodeBtn.addEventListener('click', function() {
                    sendCodeMessage(false);
                });

                authResendCodeBtn.addEventListener('click', function() {
                    sendCodeMessage(true);
                });

                topSignoutBtn.addEventListener('click', async () => {
                    if (!state.client) return;
                    await state.client.auth.signOut();
                });

                document.addEventListener('click', function(event) {
                    if (!brandEl || !brandAccountMenu || brandAccountMenu.hidden) return;
                    if (!brandEl.contains(event.target) && !brandAccountMenu.contains(event.target)) {
                        closeBrandMenu();
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeAuthModal();
                        resolveConfirm(false);
                        closeBrandMenu();
                        closeAccountSettingsModal();
                    }
                    if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'e' && state.isEditor) {
                        state.editMode = !state.editMode;
                        applyUiState();
                    }
                });
            }

            async function refreshAuth() {
                if (!state.client) return;
                const sessionData = await state.client.auth.getSession();
                state.session = sessionData.data.session;
                state.isEditor = await checkEditorAccess();

                if (!state.session) {
                    state.editMode = false;
                    setAuthState('Public mode');
                    setAuthUser('Sign in to edit rules.');
                } else if (state.isEditor) {
                    setAuthState('Editor mode');
                    setAuthUser(getDisplayName(state.session.user));
                } else {
                    setAuthState('Signed in');
                    setAuthUser(getDisplayName(state.session.user) + ' (no editor access)');
                    state.editMode = false;
                }
                applyUiState();
            }

            async function initSupabase() {
                bindEvents();
                if (!hasSupabaseConfig) {
                    setAuthState('Public mode (Supabase not configured)');
                    setAuthUser('Configure Supabase to enable editor auth.');
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                    applyUiState();
                    render();
                    return;
                }

                state.client = window.supabase.createClient(config.url, config.anonKey);
                await refreshAuth();
                await loadRules();

                state.client.auth.onAuthStateChange(async function(_event, session) {
                    state.session = session;
                    state.isEditor = await checkEditorAccess();
                    if (!state.session) {
                        state.editMode = false;
                        setAuthState('Public mode');
                        setAuthUser('Sign in to edit rules.');
                    } else if (state.isEditor) {
                        setAuthState('Editor mode');
                        setAuthUser(getDisplayName(state.session.user));
                    } else {
                        setAuthState('Signed in');
                        setAuthUser(getDisplayName(state.session.user) + ' (no editor access)');
                        state.editMode = false;
                    }
                    applyUiState();
                });

                state.channel = state.client
                    .channel('rules-live')
                    .on('postgres_changes', { event: '*', schema: 'public', table: 'rules' }, async function() {
                        await loadRules();
                    })
                    .subscribe();
            }

                initSupabase();
            })();
        });
    </script>
    <script src="../site-settings.js"></script>
    <script src="../analytics.js"></script>
    <script src="../transitions.js"></script>
</body>
</html>
