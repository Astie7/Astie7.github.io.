<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rules · Pantheverse</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap">
    <link rel="icon" type="image/webp" href="../Pantheverse.webp">
    <link rel="stylesheet" href="../critical.css">
    <link rel="preload" href="../style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="../style.css"></noscript>
    <script src="../supabase-config.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="page page-rules">
    <header class="shell topbar">
        <div class="brand">
            <span class="dot"></span>
            <span data-setting-key="brand_name">Pantheverse</span>
        </div>
        <nav class="nav">
            <a href="../">Home</a>
            <a class="active" href="./">Rules</a>
            <a href="../about/">About</a>
            <a class="btn btn-primary" data-setting-key="discord_invite_url" data-setting-attr="href" href="https://discord.gg/9qpju32M2S" target="_blank" rel="noopener">Join Discord</a>
        </nav>
    </header>

    <main class="shell rules-layout">
        <section class="rules-hero-card">
            <div class="section-head rules-head">
                <p class="eyebrow">Rules</p>
                <h1>Divine Laws of Pantheverse <span aria-hidden="true">∞</span></h1>
                <p class="rules-lead">These keep the energy high and the space safe. Know them before you dive in.</p>
            </div>

            <aside class="rules-admin-card">
                <div class="rules-auth">
                    <div class="auth-state-wrap">
                        <div id="auth-state" class="auth-state">Public mode</div>
                        <p id="auth-user" class="auth-user">Sign in to edit rules.</p>
                        <p class="auth-hint">Everyone can view. Approved editors can change rules.</p>
                    </div>
                    <div class="auth-actions">
                        <button id="auth-open-btn" class="btn btn-ghost" type="button">Editor sign in</button>
                        <button id="auth-signout-btn" class="btn btn-ghost" type="button">Sign out</button>
                    </div>
                </div>

                <div id="rules-controls" class="rules-controls">
                    <button id="enter-edit-btn" class="edit-btn" type="button">Enter edit mode</button>
                    <button id="exit-edit-btn" class="btn btn-ghost" type="button">Exit edit mode</button>
                </div>
            </aside>
        </section>

        <div id="edit-panel" class="rules-edit-panel">
            <div class="edit-row">
                <input id="new-rule" class="edit-input" type="text" placeholder="Add a new rule..." />
                <button id="add-rule-btn" class="edit-btn" type="button">+ Add rule</button>
            </div>
            <div class="bulk-row">
                <button id="select-all-btn" class="btn btn-ghost" type="button">Select all</button>
                <button id="clear-selection-btn" class="btn btn-ghost" type="button">Clear</button>
                <button id="delete-selected-btn" class="btn btn-ghost danger" type="button">Delete selected</button>
                <span id="selected-count" class="bulk-count">0 selected</span>
            </div>
            <p class="edit-note">Editor mode is on. Changes are saved to Supabase and shown live to everyone.</p>
        </div>

        <ul id="rules-list" class="rules-list"></ul>

        <div class="section-card stack">
            <h3>Future decrees</h3>
            <p>That is all for now. More Pantheverse rules may be written as the universe expands. Stay tuned for updates and cosmic tweaks.</p>
            <div class="hero-actions">
                <a class="btn btn-primary" data-setting-key="discord_invite_url" data-setting-attr="href" href="https://discord.gg/9qpju32M2S" target="_blank" rel="noopener">Acknowledge & join</a>
                <a class="btn btn-ghost" href="../">Back home</a>
            </div>
        </div>
    </main>

    <div id="auth-modal" class="auth-modal" aria-hidden="true">
        <div class="auth-card">
            <h3>Editor Sign In</h3>
            <p>Only approved editor accounts can modify rules.</p>
            <label for="auth-email">Email</label>
            <input id="auth-email" class="edit-input" type="email" placeholder="you@example.com" autocomplete="email">
            <label for="auth-password">Password</label>
            <input id="auth-password" class="edit-input" type="password" placeholder="Password" autocomplete="current-password">
            <div class="auth-card-actions">
                <button id="auth-login-btn" class="edit-btn" type="button">Sign in</button>
                <button id="auth-cancel-btn" class="btn btn-ghost" type="button">Cancel</button>
            </div>
            <p id="auth-message" class="auth-message"></p>
        </div>
    </div>

    <div id="confirm-modal" class="confirm-modal" aria-hidden="true" hidden>
        <div class="confirm-card">
            <h3 id="confirm-title">Confirm action</h3>
            <p id="confirm-text">Are you sure?</p>
            <div class="confirm-actions">
                <button id="confirm-ok" class="edit-btn" type="button">Confirm</button>
                <button id="confirm-cancel" class="btn btn-ghost" type="button">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rules-toast" class="rules-toast" aria-live="polite" aria-atomic="true"></div>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            (function() {
            const config = window.PV_SUPABASE || {};
            const hasSupabaseConfig = !!(config.url && config.anonKey && window.supabase && window.supabase.createClient);
            const enterEditBtn = document.getElementById('enter-edit-btn');
            const exitEditBtn = document.getElementById('exit-edit-btn');
            const controls = document.getElementById('rules-controls');
            const panel = document.getElementById('edit-panel');
            const listEl = document.getElementById('rules-list');
            const addBtn = document.getElementById('add-rule-btn');
            const newInput = document.getElementById('new-rule');
            const selectAllBtn = document.getElementById('select-all-btn');
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            const deleteSelectedBtn = document.getElementById('delete-selected-btn');
            const selectedCountEl = document.getElementById('selected-count');
            const authStateEl = document.getElementById('auth-state');
            const authUserEl = document.getElementById('auth-user');
            const authOpenBtn = document.getElementById('auth-open-btn');
            const authSignoutBtn = document.getElementById('auth-signout-btn');
            const authModal = document.getElementById('auth-modal');
            const authEmail = document.getElementById('auth-email');
            const authPassword = document.getElementById('auth-password');
            const authLoginBtn = document.getElementById('auth-login-btn');
            const authCancelBtn = document.getElementById('auth-cancel-btn');
            const authMessage = document.getElementById('auth-message');
            const confirmModal = document.getElementById('confirm-modal');
            const confirmTitle = document.getElementById('confirm-title');
            const confirmText = document.getElementById('confirm-text');
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            const toastEl = document.getElementById('rules-toast');

            const defaultRules = [
                'NSFW is eternally forbidden and is never allowed in any form.',
                'Racism, hate speech, or discrimination is forbidden across all realms.',
                'Spamming is allowed only if it doesn’t intentionally harm or break the server.',
                'Advertising or promoting unrelated servers is forbidden.',
                'Impersonation of members, bots, or entities is forbidden.',
                'Malicious links, scams, or harmful content are forbidden.',
                'Respect channel order — post content where it belongs.',
                'Evading punishments or bypassing restrictions is forbidden.',
                'Excessive disruption intended to ruin others’ experience is forbidden.',
                'Alternate accounts used for abuse or evasion are forbidden.',
                'Use reason and restraint — loopholes do not grant immunity.'
            ];

            const state = {
                client: null,
                session: null,
                isEditor: false,
                editMode: false,
                rules: [],
                channel: null,
                confirmResolver: null,
                toastTimer: null,
                dragRuleId: null,
                pending: false,
                selectedRuleIds: new Set()
            };

            function setAuthMessage(message, isError) {
                authMessage.textContent = message;
                authMessage.className = isError ? 'auth-message error' : 'auth-message';
            }

            function setAuthState(text) {
                authStateEl.textContent = text;
            }

            function setAuthUser(text) {
                authUserEl.textContent = text;
            }

            function openAuthModal() {
                authModal.classList.add('open');
                authModal.setAttribute('aria-hidden', 'false');
                setAuthMessage('', false);
                authEmail.focus();
            }

            function closeAuthModal() {
                authModal.classList.remove('open');
                authModal.setAttribute('aria-hidden', 'true');
                authPassword.value = '';
                setAuthMessage('', false);
            }

            function openConfirmModal(title, message) {
                confirmTitle.textContent = title;
                confirmText.textContent = message;
                confirmModal.hidden = false;
                confirmModal.classList.add('open');
                confirmModal.setAttribute('aria-hidden', 'false');
            }

            function closeConfirmModal() {
                confirmModal.classList.remove('open');
                confirmModal.setAttribute('aria-hidden', 'true');
                confirmModal.hidden = true;
            }

            function askConfirm(title, message) {
                openConfirmModal(title, message);
                return new Promise((resolve) => {
                    state.confirmResolver = resolve;
                });
            }

            function resolveConfirm(value) {
                const resolver = state.confirmResolver;
                state.confirmResolver = null;
                closeConfirmModal();
                if (typeof resolver === 'function') {
                    resolver(value);
                }
            }

            function showToast(message, kind) {
                if (!toastEl) return;
                if (state.toastTimer) {
                    clearTimeout(state.toastTimer);
                    state.toastTimer = null;
                }
                toastEl.textContent = message;
                toastEl.className = 'rules-toast';
                if (kind === 'error') toastEl.classList.add('is-error');
                toastEl.classList.add('open');
                state.toastTimer = setTimeout(function() {
                    toastEl.classList.remove('open');
                    state.toastTimer = null;
                }, 1900);
            }

            function getSortedRules() {
                return state.rules.slice().sort((a, b) => (a.position || 0) - (b.position || 0));
            }

            function setBusy(flag) {
                state.pending = !!flag;
                addBtn.disabled = state.pending;
                selectAllBtn.disabled = state.pending;
                clearSelectionBtn.disabled = state.pending;
                deleteSelectedBtn.disabled = state.pending || state.selectedRuleIds.size === 0;
            }

            function updateSelectionUi() {
                selectedCountEl.textContent = state.selectedRuleIds.size + ' selected';
                deleteSelectedBtn.disabled = state.pending || state.selectedRuleIds.size === 0;
            }

            function moveRuleBefore(dragRuleId, targetRuleId) {
                const sorted = getSortedRules();
                const fromIndex = sorted.findIndex(function(rule) { return rule.id === dragRuleId; });
                const toIndex = sorted.findIndex(function(rule) { return rule.id === targetRuleId; });
                if (fromIndex < 0 || toIndex < 0 || fromIndex === toIndex) return false;

                const moved = sorted.splice(fromIndex, 1)[0];
                sorted.splice(toIndex, 0, moved);
                state.rules = sorted.map(function(rule, index) {
                    return Object.assign({}, rule, { position: index + 1 });
                });
                return true;
            }

            function render() {
                listEl.innerHTML = '';
                const rules = getSortedRules();

                const validIds = new Set(
                    rules.filter(function(rule) {
                        return !!rule.id;
                    }).map(function(rule) {
                        return rule.id;
                    })
                );
                state.selectedRuleIds.forEach(function(id) {
                    if (!validIds.has(id)) state.selectedRuleIds.delete(id);
                });
                updateSelectionUi();

                if (!rules.length) {
                    const li = document.createElement('li');
                    const span = document.createElement('span');
                    span.className = 'rule-text';
                    span.textContent = 'No rules found yet.';
                    li.appendChild(span);
                    listEl.appendChild(li);
                    return;
                }

                rules.forEach((rule) => {
                    const li = document.createElement('li');
                    li.dataset.ruleId = rule.id || '';
                    const span = document.createElement('span');
                    span.className = 'rule-text';
                    span.textContent = rule.text;

                    if (state.isEditor && state.editMode && rule.id) {
                        li.classList.add('is-draggable');
                        li.draggable = !state.pending;

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'rule-select';
                        checkbox.checked = state.selectedRuleIds.has(rule.id);
                        checkbox.disabled = state.pending;
                        checkbox.addEventListener('change', function() {
                            if (checkbox.checked) {
                                state.selectedRuleIds.add(rule.id);
                            } else {
                                state.selectedRuleIds.delete(rule.id);
                            }
                            updateSelectionUi();
                        });
                        li.appendChild(checkbox);

                        const handle = document.createElement('button');
                        handle.type = 'button';
                        handle.className = 'drag-handle';
                        handle.textContent = '::';
                        handle.title = 'Drag to reorder';
                        handle.disabled = state.pending;
                        li.appendChild(handle);

                        li.addEventListener('dragstart', function() {
                            state.dragRuleId = rule.id;
                            li.classList.add('is-dragging');
                        });
                        li.addEventListener('dragend', function() {
                            state.dragRuleId = null;
                            li.classList.remove('is-dragging');
                            li.classList.remove('drag-over');
                        });
                        li.addEventListener('dragover', function(event) {
                            if (!state.dragRuleId || state.dragRuleId === rule.id) return;
                            event.preventDefault();
                            li.classList.add('drag-over');
                        });
                        li.addEventListener('dragleave', function() {
                            li.classList.remove('drag-over');
                        });
                        li.addEventListener('drop', function(event) {
                            event.preventDefault();
                            li.classList.remove('drag-over');
                            if (moveRuleBefore(state.dragRuleId, rule.id)) {
                                render();
                                saveRuleOrder();
                            }
                        });

                        li.appendChild(span);

                        const actions = document.createElement('div');
                        actions.className = 'rule-actions';

                        const del = document.createElement('button');
                        del.className = 'delete-rule-btn';
                        del.textContent = 'Delete';
                        del.type = 'button';
                        del.disabled = state.pending;
                        del.addEventListener('click', () => deleteRule(rule.id));

                        actions.appendChild(del);
                        li.appendChild(actions);
                        actions.style.display = 'flex';
                    } else {
                        li.appendChild(span);
                    }
                    listEl.appendChild(li);
                });
            }

            function applyUiState() {
                authSignoutBtn.style.display = state.session ? 'inline-flex' : 'none';
                authOpenBtn.style.display = state.session ? 'none' : 'inline-flex';
                controls.style.display = state.isEditor ? 'flex' : 'none';
                enterEditBtn.style.display = state.editMode ? 'none' : 'inline-flex';
                exitEditBtn.style.display = state.editMode ? 'inline-flex' : 'none';
                panel.style.display = state.isEditor && state.editMode ? 'flex' : 'none';
                document.body.classList.toggle('is-edit-mode', !!state.editMode);
                if (!state.editMode) {
                    state.selectedRuleIds.clear();
                }
                setBusy(state.pending);
                render();
            }

            async function checkEditorAccess() {
                if (!state.client || !state.session) return false;
                const userId = state.session.user.id;
                const { data, error } = await state.client
                    .from('editors')
                    .select('user_id')
                    .eq('user_id', userId)
                    .maybeSingle();

                if (error && error.code !== 'PGRST116') {
                    console.error(error);
                    return false;
                }
                return !!data;
            }

            async function loadRules() {
                if (!state.client) {
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                    render();
                    return;
                }
                const { data, error } = await state.client
                    .from('rules')
                    .select('id, position, text')
                    .order('position', { ascending: true });

                if (error) {
                    console.error(error);
                    setAuthState('Rules failed to load.');
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                } else {
                    state.rules = data || [];
                }
                render();
            }

            async function persistRuleOrderViaUpdates() {
                const sorted = getSortedRules().filter(function(rule) {
                    return !!rule.id && !String(rule.id).startsWith('tmp:');
                });
                const offset = sorted.length + 1000;

                for (let i = 0; i < sorted.length; i++) {
                    const row = sorted[i];
                    const { error } = await state.client
                        .from('rules')
                        .update({ position: offset + i + 1 })
                        .eq('id', row.id);
                    if (error) return { error: error };
                }

                for (let i = 0; i < sorted.length; i++) {
                    const row = sorted[i];
                    const { error } = await state.client
                        .from('rules')
                        .update({ position: i + 1 })
                        .eq('id', row.id);
                    if (error) return { error: error };
                }

                return { error: null };
            }

            async function persistRuleOrder() {
                if (!state.client) return { error: null };
                const ids = getSortedRules()
                    .filter(function(rule) { return !!rule.id && !String(rule.id).startsWith('tmp:'); })
                    .map(function(rule) { return rule.id; });
                if (!ids.length) return { error: null };
                const rpcResult = await state.client.rpc('reorder_rules', { rule_ids: ids });
                if (!rpcResult.error) return rpcResult;
                return persistRuleOrderViaUpdates();
            }

            async function saveRuleOrder() {
                if (!state.client || !state.isEditor || !state.editMode) return;
                if (state.pending) return;
                setBusy(true);
                const { error } = await persistRuleOrder();
                if (error) {
                    showToast('Order save failed.', 'error');
                    console.error(error);
                    await loadRules();
                    setBusy(false);
                    return;
                }
                await loadRules();
                setBusy(false);
                showToast('Order saved.');
            }

            async function addRule() {
                if (!state.isEditor || state.pending) return;
                const text = newInput.value.trim();
                if (!text) return;

                setBusy(true);

                const maxPos = state.rules.reduce((m, r) => Math.max(m, r.position || 0), 0);
                const { error } = await state.client
                    .from('rules')
                    .insert({ text: text, position: maxPos + 1 })
                    .select('id')
                    .single();
                if (error) {
                    setAuthState('Add failed.');
                    showToast('Add failed.', 'error');
                    console.error(error);
                    setBusy(false);
                    return;
                }
                newInput.value = '';
                await loadRules();
                setBusy(false);
                showToast('Rule added.');
            }

            async function deleteRule(ruleId) {
                if (!state.isEditor || state.pending) return;
                const allowed = await askConfirm('Delete rule', 'Delete this rule?');
                if (!allowed) return;
                setBusy(true);

                const { error } = await state.client.from('rules').delete().eq('id', ruleId);
                if (error) {
                    setAuthState('Delete failed.');
                    showToast('Delete failed.', 'error');
                    console.error(error);
                    setBusy(false);
                    return;
                }
                state.selectedRuleIds.delete(ruleId);
                const orderResult = await persistRuleOrder();
                if (orderResult.error) {
                    await loadRules();
                    showToast('Rule deleted, reorder sync failed.', 'error');
                    console.error(orderResult.error);
                    setBusy(false);
                    return;
                }
                await loadRules();
                setBusy(false);
                showToast('Rule deleted.');
            }

            async function deleteSelectedRules() {
                if (!state.isEditor || state.pending) return;
                const ids = Array.from(state.selectedRuleIds);
                if (!ids.length) return;
                const allowed = await askConfirm('Delete selected', 'Delete ' + ids.length + ' selected rules?');
                if (!allowed) return;
                setBusy(true);

                const { error } = await state.client.from('rules').delete().in('id', ids);
                if (error) {
                    setAuthState('Delete failed.');
                    showToast('Delete failed.', 'error');
                    console.error(error);
                    setBusy(false);
                    return;
                }
                state.selectedRuleIds.clear();
                const orderResult = await persistRuleOrder();
                if (orderResult.error) {
                    await loadRules();
                    showToast('Rules deleted, reorder sync failed.', 'error');
                    console.error(orderResult.error);
                    setBusy(false);
                    return;
                }
                await loadRules();
                setBusy(false);
                showToast(ids.length + ' rules deleted.');
            }

            function bindEvents() {
                enterEditBtn.addEventListener('click', () => {
                    if (!state.isEditor) {
                        return;
                    }
                    askConfirm('Edit mode', 'Enter edit mode?').then((allowed) => {
                        if (!allowed) return;
                        state.editMode = true;
                        applyUiState();
                    });
                });

                exitEditBtn.addEventListener('click', () => {
                    askConfirm('Edit mode', 'Exit edit mode?').then((allowed) => {
                        if (!allowed) return;
                        state.editMode = false;
                        applyUiState();
                    });
                });

                addBtn.addEventListener('click', addRule);
                newInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') addRule();
                });
                selectAllBtn.addEventListener('click', function() {
                    if (state.pending) return;
                    getSortedRules().forEach(function(rule) {
                        if (rule.id) state.selectedRuleIds.add(rule.id);
                    });
                    render();
                });
                clearSelectionBtn.addEventListener('click', function() {
                    if (state.pending) return;
                    state.selectedRuleIds.clear();
                    render();
                });
                deleteSelectedBtn.addEventListener('click', deleteSelectedRules);

                authOpenBtn.addEventListener('click', openAuthModal);
                authCancelBtn.addEventListener('click', closeAuthModal);
                authModal.addEventListener('click', (e) => {
                    if (e.target === authModal) closeAuthModal();
                });
                confirmModal.addEventListener('click', (e) => {
                    if (e.target === confirmModal) resolveConfirm(false);
                });
                confirmOk.addEventListener('click', () => resolveConfirm(true));
                confirmCancel.addEventListener('click', () => resolveConfirm(false));

                authLoginBtn.addEventListener('click', async () => {
                    if (!state.client) return;
                    const email = authEmail.value.trim();
                    const password = authPassword.value;
                    if (!email || !password) {
                        setAuthMessage('Email and password are required.', true);
                        return;
                    }
                    const { error } = await state.client.auth.signInWithPassword({ email: email, password: password });
                    if (error) {
                        setAuthMessage(error.message || 'Sign in failed.', true);
                        return;
                    }
                    closeAuthModal();
                });

                authSignoutBtn.addEventListener('click', async () => {
                    if (!state.client) return;
                    await state.client.auth.signOut();
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeAuthModal();
                        resolveConfirm(false);
                    }
                    if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'e' && state.isEditor) {
                        state.editMode = !state.editMode;
                        applyUiState();
                    }
                });
            }

            async function refreshAuth() {
                if (!state.client) return;
                const sessionData = await state.client.auth.getSession();
                state.session = sessionData.data.session;
                state.isEditor = await checkEditorAccess();

                if (!state.session) {
                    state.editMode = false;
                    setAuthState('Public mode');
                    setAuthUser('Sign in to edit rules.');
                } else if (state.isEditor) {
                    setAuthState('Editor mode');
                    setAuthUser(state.session.user.email || '');
                } else {
                    setAuthState('Signed in');
                    setAuthUser((state.session.user.email || '') + ' (no editor access)');
                    state.editMode = false;
                }
                applyUiState();
            }

            async function initSupabase() {
                bindEvents();
                if (!hasSupabaseConfig) {
                    setAuthState('Public mode (Supabase not configured)');
                    setAuthUser('Configure Supabase to enable editor auth.');
                    authOpenBtn.style.display = 'none';
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                    render();
                    return;
                }

                state.client = window.supabase.createClient(config.url, config.anonKey);
                await refreshAuth();
                await loadRules();

                state.client.auth.onAuthStateChange(async function(_event, session) {
                    state.session = session;
                    state.isEditor = await checkEditorAccess();
                    if (!state.session) {
                        state.editMode = false;
                        setAuthState('Public mode');
                        setAuthUser('Sign in to edit rules.');
                    } else if (state.isEditor) {
                        setAuthState('Editor mode');
                        setAuthUser(state.session.user.email || '');
                    } else {
                        setAuthState('Signed in');
                        setAuthUser((state.session.user.email || '') + ' (no editor access)');
                        state.editMode = false;
                    }
                    applyUiState();
                });

                state.channel = state.client
                    .channel('rules-live')
                    .on('postgres_changes', { event: '*', schema: 'public', table: 'rules' }, async function() {
                        await loadRules();
                    })
                    .subscribe();
            }

                initSupabase();
            })();
        });
    </script>
    <script src="../site-settings.js"></script>
    <script src="../analytics.js"></script>
    <script src="../transitions.js"></script>
</body>
</html>
