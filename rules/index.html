<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rules · Pantheverse</title>
    <link rel="icon" type="image/webp" href="../Pantheverse.webp">
    <link rel="stylesheet" href="../style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="./supabase-config.js"></script>
</head>
<body class="page page-rules">
    <header class="shell topbar">
        <div class="brand">
            <span class="dot"></span>
            <span>Pantheverse</span>
        </div>
        <nav class="nav">
            <a href="../">Home</a>
            <a class="active" href="./">Rules</a>
            <a href="../about/">About</a>
            <a class="btn btn-primary" href="https://discord.gg/9qpju32M2S" target="_blank" rel="noopener">Join Discord</a>
        </nav>
    </header>

    <main class="shell rules-layout">
        <section class="rules-hero-card">
            <div class="section-head rules-head">
                <p class="eyebrow">Rules</p>
                <h1>Divine Laws of Pantheverse <span aria-hidden="true">∞</span></h1>
                <p class="rules-lead">These keep the energy high and the space safe. Know them before you dive in.</p>
            </div>

            <aside class="rules-admin-card">
                <div class="rules-auth">
                    <div class="auth-state-wrap">
                        <div id="auth-state" class="auth-state">Public mode</div>
                        <p id="auth-user" class="auth-user">Sign in to edit rules.</p>
                        <p class="auth-hint">Everyone can view. Approved editors can change rules.</p>
                    </div>
                    <div class="auth-actions">
                        <button id="auth-open-btn" class="btn btn-ghost" type="button">Editor sign in</button>
                        <button id="auth-signout-btn" class="btn btn-ghost" type="button">Sign out</button>
                    </div>
                </div>

                <div id="rules-controls" class="rules-controls">
                    <button id="enter-edit-btn" class="edit-btn" type="button">Enter edit mode</button>
                    <button id="exit-edit-btn" class="btn btn-ghost" type="button">Exit edit mode</button>
                </div>
            </aside>
        </section>

        <div id="edit-panel" class="rules-edit-panel">
            <div class="edit-row">
                <input id="new-rule" class="edit-input" type="text" placeholder="Add a new rule..." />
                <button id="add-rule-btn" class="edit-btn" type="button">+ Add rule</button>
            </div>
            <p class="edit-note">Editor mode is on. Changes are saved to Supabase and shown live to everyone.</p>
        </div>

        <ul id="rules-list" class="rules-list"></ul>

        <div class="section-card stack">
            <h3>Future decrees</h3>
            <p>That is all for now. More Pantheverse rules may be written as the universe expands. Stay tuned for updates and cosmic tweaks.</p>
            <div class="hero-actions">
                <a class="btn btn-primary" href="https://discord.gg/9qpju32M2S" target="_blank" rel="noopener">Acknowledge & join</a>
                <a class="btn btn-ghost" href="../">Back home</a>
            </div>
        </div>
    </main>

    <div id="auth-modal" class="auth-modal" aria-hidden="true">
        <div class="auth-card">
            <h3>Editor Sign In</h3>
            <p>Only approved editor accounts can modify rules.</p>
            <label for="auth-email">Email</label>
            <input id="auth-email" class="edit-input" type="email" placeholder="you@example.com" autocomplete="email">
            <label for="auth-password">Password</label>
            <input id="auth-password" class="edit-input" type="password" placeholder="Password" autocomplete="current-password">
            <div class="auth-card-actions">
                <button id="auth-login-btn" class="edit-btn" type="button">Sign in</button>
                <button id="auth-cancel-btn" class="btn btn-ghost" type="button">Cancel</button>
            </div>
            <p id="auth-message" class="auth-message"></p>
        </div>
    </div>

    <div id="confirm-modal" class="confirm-modal" aria-hidden="true" hidden>
        <div class="confirm-card">
            <h3 id="confirm-title">Confirm action</h3>
            <p id="confirm-text">Are you sure?</p>
            <div class="confirm-actions">
                <button id="confirm-ok" class="edit-btn" type="button">Confirm</button>
                <button id="confirm-cancel" class="btn btn-ghost" type="button">Cancel</button>
            </div>
        </div>
    </div>

    <div id="rules-toast" class="rules-toast" aria-live="polite" aria-atomic="true"></div>

    <script>
        (function() {
            const config = window.PV_SUPABASE || {};
            const hasSupabaseConfig = !!(config.url && config.anonKey && window.supabase && window.supabase.createClient);
            const enterEditBtn = document.getElementById('enter-edit-btn');
            const exitEditBtn = document.getElementById('exit-edit-btn');
            const controls = document.getElementById('rules-controls');
            const panel = document.getElementById('edit-panel');
            const listEl = document.getElementById('rules-list');
            const addBtn = document.getElementById('add-rule-btn');
            const newInput = document.getElementById('new-rule');
            const authStateEl = document.getElementById('auth-state');
            const authUserEl = document.getElementById('auth-user');
            const authOpenBtn = document.getElementById('auth-open-btn');
            const authSignoutBtn = document.getElementById('auth-signout-btn');
            const authModal = document.getElementById('auth-modal');
            const authEmail = document.getElementById('auth-email');
            const authPassword = document.getElementById('auth-password');
            const authLoginBtn = document.getElementById('auth-login-btn');
            const authCancelBtn = document.getElementById('auth-cancel-btn');
            const authMessage = document.getElementById('auth-message');
            const confirmModal = document.getElementById('confirm-modal');
            const confirmTitle = document.getElementById('confirm-title');
            const confirmText = document.getElementById('confirm-text');
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            const toastEl = document.getElementById('rules-toast');

            const defaultRules = [
                'NSFW is eternally forbidden and is never allowed in any form.',
                'Racism, hate speech, or discrimination is forbidden across all realms.',
                'Spamming is allowed only if it doesn’t intentionally harm or break the server.',
                'Advertising or promoting unrelated servers is forbidden.',
                'Impersonation of members, bots, or entities is forbidden.',
                'Malicious links, scams, or harmful content are forbidden.',
                'Respect channel order — post content where it belongs.',
                'Evading punishments or bypassing restrictions is forbidden.',
                'Excessive disruption intended to ruin others’ experience is forbidden.',
                'Alternate accounts used for abuse or evasion are forbidden.',
                'Use reason and restraint — loopholes do not grant immunity.'
            ];

            const state = {
                client: null,
                session: null,
                isEditor: false,
                editMode: false,
                rules: [],
                channel: null,
                confirmResolver: null,
                toastTimer: null
            };

            function setAuthMessage(message, isError) {
                authMessage.textContent = message;
                authMessage.className = isError ? 'auth-message error' : 'auth-message';
            }

            function setAuthState(text) {
                authStateEl.textContent = text;
            }

            function setAuthUser(text) {
                authUserEl.textContent = text;
            }

            function openAuthModal() {
                authModal.classList.add('open');
                authModal.setAttribute('aria-hidden', 'false');
                setAuthMessage('', false);
                authEmail.focus();
            }

            function closeAuthModal() {
                authModal.classList.remove('open');
                authModal.setAttribute('aria-hidden', 'true');
                authPassword.value = '';
                setAuthMessage('', false);
            }

            function openConfirmModal(title, message) {
                confirmTitle.textContent = title;
                confirmText.textContent = message;
                confirmModal.hidden = false;
                confirmModal.classList.add('open');
                confirmModal.setAttribute('aria-hidden', 'false');
            }

            function closeConfirmModal() {
                confirmModal.classList.remove('open');
                confirmModal.setAttribute('aria-hidden', 'true');
                confirmModal.hidden = true;
            }

            function askConfirm(title, message) {
                openConfirmModal(title, message);
                return new Promise((resolve) => {
                    state.confirmResolver = resolve;
                });
            }

            function resolveConfirm(value) {
                const resolver = state.confirmResolver;
                state.confirmResolver = null;
                closeConfirmModal();
                if (typeof resolver === 'function') {
                    resolver(value);
                }
            }

            function showToast(message, kind) {
                if (!toastEl) return;
                if (state.toastTimer) {
                    clearTimeout(state.toastTimer);
                    state.toastTimer = null;
                }
                toastEl.textContent = message;
                toastEl.className = 'rules-toast';
                if (kind === 'error') toastEl.classList.add('is-error');
                toastEl.classList.add('open');
                state.toastTimer = setTimeout(function() {
                    toastEl.classList.remove('open');
                    state.toastTimer = null;
                }, 1900);
            }

            function getSortedRules() {
                return state.rules.slice().sort((a, b) => (a.position || 0) - (b.position || 0));
            }

            function render() {
                listEl.innerHTML = '';
                const rules = getSortedRules();

                if (!rules.length) {
                    const li = document.createElement('li');
                    const span = document.createElement('span');
                    span.className = 'rule-text';
                    span.textContent = 'No rules found yet.';
                    li.appendChild(span);
                    listEl.appendChild(li);
                    return;
                }

                rules.forEach((rule, idx) => {
                    const li = document.createElement('li');
                    const span = document.createElement('span');
                    span.className = 'rule-text';
                    span.textContent = rule.text;
                    li.appendChild(span);

                    if (state.isEditor && state.editMode && rule.id) {
                        const actions = document.createElement('div');
                        actions.className = 'rule-actions';

                        const del = document.createElement('button');
                        del.className = 'delete-rule-btn';
                        del.textContent = 'Delete';
                        del.type = 'button';
                        del.addEventListener('click', () => deleteRule(rule.id));

                        actions.appendChild(del);
                        li.appendChild(actions);
                        actions.style.display = 'flex';
                    }
                    listEl.appendChild(li);
                });
            }

            function applyUiState() {
                authSignoutBtn.style.display = state.session ? 'inline-flex' : 'none';
                authOpenBtn.style.display = state.session ? 'none' : 'inline-flex';
                controls.style.display = state.isEditor ? 'flex' : 'none';
                enterEditBtn.style.display = state.editMode ? 'none' : 'inline-flex';
                exitEditBtn.style.display = state.editMode ? 'inline-flex' : 'none';
                panel.style.display = state.isEditor && state.editMode ? 'flex' : 'none';
                document.body.classList.toggle('is-edit-mode', !!state.editMode);
                render();
            }

            async function checkEditorAccess() {
                if (!state.client || !state.session) return false;
                const userId = state.session.user.id;
                const { data, error } = await state.client
                    .from('editors')
                    .select('user_id')
                    .eq('user_id', userId)
                    .maybeSingle();

                if (error && error.code !== 'PGRST116') {
                    console.error(error);
                    return false;
                }
                return !!data;
            }

            async function loadRules() {
                if (!state.client) {
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                    render();
                    return;
                }
                const { data, error } = await state.client
                    .from('rules')
                    .select('id, position, text')
                    .order('position', { ascending: true });

                if (error) {
                    console.error(error);
                    setAuthState('Rules failed to load.');
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                } else {
                    state.rules = data || [];
                }
                render();
            }

            async function normalizeRulePositions() {
                const sorted = getSortedRules();
                for (let i = 0; i < sorted.length; i++) {
                    const row = sorted[i];
                    const nextPos = i + 1;
                    if (row.id && row.position !== nextPos) {
                        const { error } = await state.client.from('rules').update({ position: nextPos }).eq('id', row.id);
                        if (error) {
                            console.error(error);
                            break;
                        }
                    }
                }
            }

            async function addRule() {
                if (!state.isEditor) return;
                const text = newInput.value.trim();
                if (!text) return;

                const maxPos = state.rules.reduce((m, r) => Math.max(m, r.position || 0), 0);
                const { error } = await state.client.from('rules').insert({ text: text, position: maxPos + 1 });
                if (error) {
                    setAuthState('Add failed.');
                    showToast('Add failed.', 'error');
                    console.error(error);
                    return;
                }
                newInput.value = '';
                await loadRules();
                showToast('Rule added.');
            }

            async function deleteRule(ruleId) {
                if (!state.isEditor) return;
                const allowed = await askConfirm('Delete rule', 'Delete this rule?');
                if (!allowed) return;
                const { error } = await state.client.from('rules').delete().eq('id', ruleId);
                if (error) {
                    setAuthState('Delete failed.');
                    showToast('Delete failed.', 'error');
                    console.error(error);
                    return;
                }
                await loadRules();
                await normalizeRulePositions();
                await loadRules();
                showToast('Rule deleted.');
            }

            function bindEvents() {
                enterEditBtn.addEventListener('click', () => {
                    if (!state.isEditor) {
                        return;
                    }
                    askConfirm('Edit mode', 'Enter edit mode?').then((allowed) => {
                        if (!allowed) return;
                        state.editMode = true;
                        applyUiState();
                    });
                });

                exitEditBtn.addEventListener('click', () => {
                    askConfirm('Edit mode', 'Exit edit mode?').then((allowed) => {
                        if (!allowed) return;
                        state.editMode = false;
                        applyUiState();
                    });
                });

                addBtn.addEventListener('click', addRule);
                newInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') addRule();
                });

                authOpenBtn.addEventListener('click', openAuthModal);
                authCancelBtn.addEventListener('click', closeAuthModal);
                authModal.addEventListener('click', (e) => {
                    if (e.target === authModal) closeAuthModal();
                });
                confirmModal.addEventListener('click', (e) => {
                    if (e.target === confirmModal) resolveConfirm(false);
                });
                confirmOk.addEventListener('click', () => resolveConfirm(true));
                confirmCancel.addEventListener('click', () => resolveConfirm(false));

                authLoginBtn.addEventListener('click', async () => {
                    if (!state.client) return;
                    const email = authEmail.value.trim();
                    const password = authPassword.value;
                    if (!email || !password) {
                        setAuthMessage('Email and password are required.', true);
                        return;
                    }
                    const { error } = await state.client.auth.signInWithPassword({ email: email, password: password });
                    if (error) {
                        setAuthMessage(error.message || 'Sign in failed.', true);
                        return;
                    }
                    closeAuthModal();
                });

                authSignoutBtn.addEventListener('click', async () => {
                    if (!state.client) return;
                    await state.client.auth.signOut();
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeAuthModal();
                        resolveConfirm(false);
                    }
                    if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'e' && state.isEditor) {
                        state.editMode = !state.editMode;
                        applyUiState();
                    }
                });
            }

            async function refreshAuth() {
                if (!state.client) return;
                const sessionData = await state.client.auth.getSession();
                state.session = sessionData.data.session;
                state.isEditor = await checkEditorAccess();

                if (!state.session) {
                    state.editMode = false;
                    setAuthState('Public mode');
                    setAuthUser('Sign in to edit rules.');
                } else if (state.isEditor) {
                    setAuthState('Editor mode');
                    setAuthUser(state.session.user.email || '');
                } else {
                    setAuthState('Signed in');
                    setAuthUser((state.session.user.email || '') + ' (no editor access)');
                    state.editMode = false;
                }
                applyUiState();
            }

            async function initSupabase() {
                bindEvents();
                if (!hasSupabaseConfig) {
                    setAuthState('Public mode (Supabase not configured)');
                    setAuthUser('Configure Supabase to enable editor auth.');
                    authOpenBtn.style.display = 'none';
                    state.rules = defaultRules.map((text, i) => ({ id: null, position: i + 1, text: text }));
                    render();
                    return;
                }

                state.client = window.supabase.createClient(config.url, config.anonKey);
                await refreshAuth();
                await loadRules();

                state.client.auth.onAuthStateChange(async function(_event, session) {
                    state.session = session;
                    state.isEditor = await checkEditorAccess();
                    if (!state.session) {
                        state.editMode = false;
                        setAuthState('Public mode');
                        setAuthUser('Sign in to edit rules.');
                    } else if (state.isEditor) {
                        setAuthState('Editor mode');
                        setAuthUser(state.session.user.email || '');
                    } else {
                        setAuthState('Signed in');
                        setAuthUser((state.session.user.email || '') + ' (no editor access)');
                        state.editMode = false;
                    }
                    applyUiState();
                });

                state.channel = state.client
                    .channel('rules-live')
                    .on('postgres_changes', { event: '*', schema: 'public', table: 'rules' }, async function() {
                        await loadRules();
                    })
                    .subscribe();
            }

            initSupabase();
        })();
    </script>
</body>
</html>
